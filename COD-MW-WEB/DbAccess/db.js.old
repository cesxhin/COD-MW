const config = require('./config.json');

const dal = () =>
{
    const pg = require('pg');
    const getClient = () =>{
        const client = new pg.Client(config);

        client.connect(err => {
          if (err) {
            console.error('connection error', err.stack)
          } else {
            console.log('connected')
          }
        })
        return client;
    }

    //login
    const login = async (email, password) =>{
      const client = getClient();
      const result = await client.query('SELECT * FROM account as a JOIN players as p ON (a.uno = p.uno) WHERE a.email_cod = $1 AND a.password = $2', [email.toLowerCase(), password]);
      client.end();
      return result.rows.length > 0 ? result.rows[0] : null;
    }

    //registration
    const registration = async (account, player) =>{
      const client = getClient();
      try {
        const accountResult = await client.query('INSERT INTO account VALUES ($1, $2, $3, $4, false) RETURNING *', [account.uno, account.password, account.emailCod, account.passwordCod]);
        const playerResult = await client.query('INSERT INTO players VALUES ($1, $2, $3) ', [player.tag_username, player.platform, player.uno]);
        return accountResult.rows.length > 0 ? accountResult.rows[0] : null;
      } catch (error) {
        return null;
      } finally {
        client.end();
        console.log('ended connection');
      }
    }

    //verify equal email
    const verifyEmail = async (emailCod) =>{
      const client = getClient();
      const result = await client.query('SELECT * FROM account where email_cod = $1', [emailCod.toLowerCase()]);
      client.end();
      return result.rows.length > 0 ? true : false;
    }

    //get exists tag_username
    const checkTagUsername = async (tagUsername) =>{
      const client = getClient();
      const result = await client.query('SELECT * FROM players where tag_username = $1', [tagUsername]);
      client.end();
      return result.rows.length > 0 ? true : false;
    }
    //create ranking schema
    const addRankingSchema = async (schema) => {
      const client = getClient();
      if(schema.gulag === undefined)
        schema.gulag = false;

      const result = await client.query(`INSERT INTO rankingschemas
        (name, points_top1, points_top2, points_top3, points_top5, points_top10, points_top15, points_top20, kill, gulag) 
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING *`, [schema.schemaName, schema.points_top1, schema.points_top2, schema.points_top3, schema.points_top5, schema.points_top10, schema.points_top15, schema.points_top20, schema.kill, schema.gulag]);
      
      client.end();
      return result.rows.length > 0 ? result.rows[0] : null;
    }

    //get ranking schemas
    const getRankingSchemas = async () => {
      const client = getClient();
      const result = await client.query('SELECT * FROM rankingschemas');
      client.end();
      return result.rows.length > 0 ? result.rows : null;
    }

    //get ranking schema by id
    const getRankingSchemaById = async (id) => {
      const client = getClient();
      const result = await client.query('SELECT * FROM rankingschemas WHERE id = $1', [id]);
      client.end();

      return result.rows.length > 0 ? result.rows[0] : null;
    }

    //update ranking schema 
    const updateRankingSchema = async (schema) => {
      const client = getClient();
      if(schema.gulag === undefined)
        schema.gulag = false;
      
      const result = await client.query(`UPDATE rankingschemas SET
      (name, points_top1, points_top2, points_top3, points_top5, points_top10, points_top15, points_top20, kill, gulag) 
      = ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      WHERE id = $11 RETURNING *`, 
      [schema.schemaName, schema.points_top1, schema.points_top2, schema.points_top3, schema.points_top5, schema.points_top10, schema.points_top15, schema.points_top20, schema.kill, schema.gulag, schema.id]);
      
      client.end();
      return result.rows.length > 0 ? result.rows[0] : null;
    }

    //delete ranking schema 
    const deleteRankingSchema = async (id) => {
      const client = getClient();
      try
      {
        const result = await client.query('DELETE FROM rankingschemas WHERE id = $1 RETURNING *', [id]);
        return result.rows.length > 0 ? result.rows[0] : null;
      }catch(Error)
      {
        if(Error.message.includes("violates"))
        {
          return 'violates'
        }else
        {
          return 'generic'
        }
      }
    }

    //create tournament
    const createTournament = async (tournaments) => {
      const client = getClient();
      const result = await client.query('INSERT INTO tournaments (start_date, start_time, number_matches, id_schema) values ($1, $2, $3, $4)  RETURNING *', [tournaments.start_date, tournaments.start_time, tournaments.number_matches, tournaments.id_schema]);
      client.end();
      return result.rows.length > 0 ? result.rows[0] : null;
    }

    //get tournaments
    const getTournaments = async () => {
      const client = getClient();
      const result = await client.query('SELECT * FROM tournaments');
      client.end();
      return result.rows.length > 0 ? result.rows : null;
    }
    //get by id tournaments
    const getTournamentsById = async (id) => {
      const client = getClient();
      const result = await client.query('SELECT * FROM tournaments WHERE id = $1', [id]);
      client.end();
      return result.rows.length > 0 ? result.rows[0] : null;
    }
    //update tournaments
    const updateTournaments = async (tournaments) => {
      const client = getClient();
      const result = await client.query('UPDATE tournaments SET start_date=$1, start_time=$2, number_matches=$3, id_schema=$4 WHERE id = $5 RETURNING *',[tournaments.start_date, tournaments.start_time, tournaments.number_matches, tournaments.id_schema, tournaments.id]);
      client.end();
      return result.rows.length > 0 ? result.rows[0] : null;
    }
    //delete tournaments
    const deleteTournaments = async (id) => {
      const client = getClient();
      try
      {
        await client.query('DELETE FROM tournaments WHERE id = $1', [id]);
        client.end();
        return;
      }catch
      {
        return 'generic'
      }
    }

    //get players
    const getPlayers = async() => {
      const client = getClient();
      const result = await client.query('SELECT * FROM players');
      client.end();

      return result.rowCount > 0 ? result.rows[0] : null;
    }
    
    //check if player already has a team
    const checkPlayerIntoTeamBy = async(tagUsername) => {
      const client = getClient();
      const result = await client.query('SELECT * FROM teams');

      /*result.rows.forEach(players => {
        players.forEach(p => {
          if(p === tagUsername)
          {
            return true;
          }
        })
     
      });*/

      /*for(let k in result.rows) {
        for(let x in result.rows[k].players)
        {
          if(result.rows[k].players[x].player === tagUsername)
          {
            return result.rows[k].name;
          }
        }
      }*/

      //Funzionante
      for(let k in result.rows) {
        if(result.rows[k].players.find(p => p.player === tagUsername))
            return result.rows[k].name;
          
        }
      return false;
    }

    //check if  players are into team
    const checkPlayersIntoTeam = async(jsonPlayers) => {
      const client = getClient();
      const result = await client.query('SELECT * FROM teams');
      //Funzionante
      for (let z in jsonPlayers)
      {
        for(let k in result.rows) {
          if(result.rows[k].players.find(p => p.player === jsonPlayers[z].player))
              return jsonPlayers[z].player;
          }
      }
      return false;
    }


    //create team
    const createTeam = async(teamName, jsonPlayers) => {
      const client = getClient();
      try {
          const result = await client.query('INSERT INTO teams VALUES ($1, $2) RETURNING *', [teamName, JSON.stringify(jsonPlayers)]);
          return result.rowCount > 0 ? result.rows[0] : null;
      } catch (error) {
        return 'error';
      } finally {
        client.end();
      }
    }



    //get global ranking by date
    const getGlobalRankings = async(startDate) => {
      const client = getClient();
      const result = await client.query('SELECT * from rankings r JOIN tournaments t ON (t.id = r.id_tournament) WHERE t.start_date = $1 ', [startDate]);
      client.end();

      return result.rowCount > 0 ? result.rows[0] : null;
    
    }


    return{
      login,
      registration,
      verifyEmail,
      checkTagUsername,

      /*addRankingSchema,
      getRankingSchemas,
      getRankingSchemaById,
      updateRankingSchema,
      deleteRankingSchema,*/
      
      /*createTournament,
      getTournaments,
      getTournamentsById,
      deleteTournaments,
      updateTournaments,*/

      checkPlayerIntoTeamBy,
      checkPlayersIntoTeam,

      createTeam,

      getGlobalRankings
    }
}

module.exports = dal;